<!DOCTYPE html>
<html>
<head>
    <title>Glyph inspector</title>
    <meta charset="utf-8">
    <script src="../bower_components/opentype.js/dist/opentype.js"></script>
</head>
<body>
<div class="container">
    <div id="glyph-display">
        <canvas id="glyph" width="500" height="500" style="background-color: palegoldenrod;"></canvas>
    </div>
</div>
<script>
    var font, glyphScale, glyphSize, glyphBaseline;
    function pathCommandToString(cmd) {
        var str = '<strong>' + cmd.type + '</strong> ' +
                ((cmd.x !== undefined) ? 'x='+cmd.x+' y='+cmd.y+' ' : '') +
                ((cmd.x1 !== undefined) ? 'x1='+cmd.x1+' y1='+cmd.y1+' ' : '') +
                ((cmd.x2 !== undefined) ? 'x2='+cmd.x2+' y2='+cmd.y2 : '');
        return str;
    }
    var arrowLength = 10,
            arrowAperture = 4;
    function drawArrow(ctx, x1, y1, x2, y2) {
        var dx = x2 - x1,
                dy = y2 - y1,
                segmentLength = Math.sqrt(dx*dx + dy*dy),
                unitx = dx / segmentLength,
                unity = dy / segmentLength,
                basex = x2 - arrowLength * unitx,
                basey = y2 - arrowLength * unity,
                normalx = arrowAperture * unity,
                normaly = -arrowAperture * unitx;
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(basex + normalx, basey + normaly);
        ctx.lineTo(basex - normalx, basey - normaly);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.fill();
    }
    /**
     * This function is Path.prototype.draw with an arrow
     * at the end of each contour.
     */
    function drawPathWithArrows(ctx, path) {
        var i, cmd, x1, y1, x2, y2;
        var arrows = [];
        ctx.beginPath();
        for (i = 0; i < path.commands.length; i += 1) {
            cmd = path.commands[i];
            if (cmd.type === 'M') {
                if(x1 !== undefined) {
                    arrows.push([ctx, x1, y1, x2, y2]);
                }
                ctx.moveTo(cmd.x, cmd.y);
            } else if (cmd.type === 'L') {
                ctx.lineTo(cmd.x, cmd.y);
                x1 = x2;
                y1 = y2;
            } else if (cmd.type === 'C') {
                ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                x1 = cmd.x2;
                y1 = cmd.y2;
            } else if (cmd.type === 'Q') {
                ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                x1 = cmd.x1;
                y1 = cmd.y1;
            } else if (cmd.type === 'Z') {
                arrows.push([ctx, x1, y1, x2, y2]);
                ctx.closePath();
            }
            x2 = cmd.x;
            y2 = cmd.y;
        }
        if (path.fill) {
            ctx.fillStyle = path.fill;
            ctx.fill();
        }
        if (path.stroke) {
            ctx.strokeStyle = path.stroke;
            ctx.lineWidth = path.strokeWidth;
            ctx.stroke();
        }
        ctx.fillStyle = '#000000';
        arrows.forEach(function(arrow) {
            drawArrow.apply(null, arrow);
        });
    }
    function displayGlyph(width, height, ctx, glyphIndex) {
//        ctx.clearRect(0, 0, width, height);
        if(glyphIndex < 0) return;
        var glyph = font.glyphs[glyphIndex],
                glyphWidth = glyph.advanceWidth * glyphScale,
                xmin = (width - glyphWidth)/2,
                xmax = (width + glyphWidth)/2,
                x0 = xmin,
                markSize = 10;
        ctx.fillStyle = '#606060';
        ctx.fillRect(xmin-markSize+1, glyphBaseline, markSize, 1);
        ctx.fillRect(xmin, glyphBaseline, 1, markSize);
        ctx.fillRect(xmax, glyphBaseline, markSize, 1);
        ctx.fillRect(xmax, glyphBaseline, 1, markSize);
        ctx.textAlign = 'center';
        ctx.fillText('0', xmin, glyphBaseline+markSize+10);
        ctx.fillText(glyph.advanceWidth, xmax, glyphBaseline+markSize+10);
        ctx.fillStyle = '#000000';
        var path = glyph.getPath(x0, glyphBaseline, glyphSize);
        path.fill = '#808080';
        path.stroke = '#000000';
        path.strokeWidth = 1.5;
        drawPathWithArrows(ctx, path);
//        glyph.drawPoints(ctx, x0, glyphBaseline, glyphSize);
    }
    function initGlyphDisplay(glyphW, glyphH, ctx) {
        var hhea = font.tables.hhea,
            maxHeight = hhea.ascender - hhea.descender;
        glyphScale = Math.min(glyphH/maxHeight, hhea.advanceWidthMax);
        glyphSize = glyphScale * font.unitsPerEm;
        glyphBaseline = glyphH * hhea.ascender / maxHeight;
        function hline(text, yunits) {
            ypx = glyphBaseline - yunits * glyphScale;
            ctx.fillText(text, 2, ypx+3);
            ctx.fillRect(80, ypx, glyphW, 1);
        }
        ctx.clearRect(0, 0, glyphW, glyphH);
        ctx.fillStyle = '#a0a0a0';
        hline('Baseline', 0);
        hline('Ascender', font.tables.hhea.ascender);
        hline('Descender', font.tables.hhea.descender);
    }
    function onFontLoaded(font) {
        window.font = font;
        var glyphCanvas = document.getElementById('glyph');
        initGlyphDisplay(glyphCanvas.width, glyphCanvas.height, glyphCanvas.getContext('2d'));
        displayGlyph(glyphCanvas.width, glyphCanvas.height, glyphCanvas.getContext('2d'), 12);
    }
    opentype.load('latinmodern-math.otf', function (err, font) {
        onFontLoaded(font);
    });
</script>
</body>
</html>