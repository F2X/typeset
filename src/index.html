<!DOCTYPE html>
<html>
<head>
    <title>Glyph inspector</title>
    <meta charset="utf-8">
    <script src="../bower_components/opentype.js/dist/opentype.js"></script>
</head>
<body>
<div class="container">
    <div style="position: relative">
        <div id="glyph-display">
            <canvas id="glyph-bg" width="500" height="500"></canvas>
            <canvas id="glyph" width="500" height="500"></canvas>
        </div>
        <div id="glyph-data"></div>
        <div style="clear: both"></div>
    </div>
    <hr>
</div>
<script>
    var font, glyphScale, glyphSize, glyphBaseline;
    function pathCommandToString(cmd) {
        var str = '<strong>' + cmd.type + '</strong> ' +
                ((cmd.x !== undefined) ? 'x='+cmd.x+' y='+cmd.y+' ' : '') +
                ((cmd.x1 !== undefined) ? 'x1='+cmd.x1+' y1='+cmd.y1+' ' : '') +
                ((cmd.x2 !== undefined) ? 'x2='+cmd.x2+' y2='+cmd.y2 : '');
        return str;
    }
    function contourToString(contour) {
        return '<pre class="contour">' + contour.map(function(point) {
                    return '<span class="' + (point.onCurve ? 'on' : 'off') + 'curve">x=' + point.x + ' y=' + point.y + '</span>';
                }).join('\n') + '</pre>';
    }
    function formatUnicode(unicode) {
        unicode = unicode.toString(16);
        if (unicode.length > 4) {
            return ("000000" + unicode.toUpperCase()).substr(-6)
        } else {
            return ("0000" + unicode.toUpperCase()).substr(-4)
        }
    }
    function displayGlyphData(glyphIndex) {
        var container = document.getElementById('glyph-data');
        if (glyphIndex < 0) {
            container.innerHTML = '';
            return;
        }
        var glyph = font.glyphs[glyphIndex],
                html;
        html = '<dt>name</dt><dd>'+glyph.name+'</dd>';
        if (glyph.unicodes.length > 0) {
            html += '<dt>unicode</dt><dd>'+ glyph.unicodes.map(formatUnicode).join(', ') +'</dd>';
        }
        html += '<dl><dt>index</dt><dd>'+glyph.index+'</dd>';
        if (glyph.xMin !== 0 || glyph.xMax !== 0 || glyph.yMin !== 0 || glyph.yMax !== 0) {
            html += '<dt>xMin</dt><dd>'+glyph.xMin+'</dd>' +
            '<dt>xMax</dt><dd>'+glyph.xMax+'</dd>' +
            '<dt>yMin</dt><dd>'+glyph.yMin+'</dd>' +
            '<dt>yMax</dt><dd>'+glyph.yMax+'</dd>';
        }
        html += '<dt>advanceWidth</dt><dd>'+glyph.advanceWidth+'</dd>';
        if(glyph.leftSideBearing !== undefined) {
            html += '<dt>leftSideBearing</dt><dd>'+glyph.leftSideBearing+'</dd>';
        }
        html += '</dl>';
        if (glyph.numberOfContours > 0) {
            var contours = glyph.getContours();
            html += 'contours:<br>' + contours.map(contourToString).join('\n');
        } else if (glyph.isComposite) {
            html += '<br>This composite glyph is a combination of :<ul><li>' +
            glyph.components.map(function(component) {
                return 'glyph '+component.glyphIndex+' at dx='+component.dx+', dy='+component.dy;
            }).join('</li><li>') + '</li></ul>';
        } else if (glyph.path) {
            html += 'path:<br><pre>  ' + glyph.path.commands.map(pathCommandToString).join('\n  ') + '\n</pre>';
        }
        container.innerHTML = html;
    }
    var arrowLength = 10,
            arrowAperture = 4;
    function drawArrow(ctx, x1, y1, x2, y2) {
        var dx = x2 - x1,
                dy = y2 - y1,
                segmentLength = Math.sqrt(dx*dx + dy*dy),
                unitx = dx / segmentLength,
                unity = dy / segmentLength,
                basex = x2 - arrowLength * unitx,
                basey = y2 - arrowLength * unity,
                normalx = arrowAperture * unity,
                normaly = -arrowAperture * unitx;
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(basex + normalx, basey + normaly);
        ctx.lineTo(basex - normalx, basey - normaly);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.fill();
    }
    /**
     * This function is Path.prototype.draw with an arrow
     * at the end of each contour.
     */
    function drawPathWithArrows(ctx, path) {
        var i, cmd, x1, y1, x2, y2;
        var arrows = [];
        ctx.beginPath();
        for (i = 0; i < path.commands.length; i += 1) {
            cmd = path.commands[i];
            if (cmd.type === 'M') {
                if(x1 !== undefined) {
                    arrows.push([ctx, x1, y1, x2, y2]);
                }
                ctx.moveTo(cmd.x, cmd.y);
            } else if (cmd.type === 'L') {
                ctx.lineTo(cmd.x, cmd.y);
                x1 = x2;
                y1 = y2;
            } else if (cmd.type === 'C') {
                ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                x1 = cmd.x2;
                y1 = cmd.y2;
            } else if (cmd.type === 'Q') {
                ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                x1 = cmd.x1;
                y1 = cmd.y1;
            } else if (cmd.type === 'Z') {
                arrows.push([ctx, x1, y1, x2, y2]);
                ctx.closePath();
            }
            x2 = cmd.x;
            y2 = cmd.y;
        }
        if (path.fill) {
            ctx.fillStyle = path.fill;
            ctx.fill();
        }
        if (path.stroke) {
            ctx.strokeStyle = path.stroke;
            ctx.lineWidth = path.strokeWidth;
            ctx.stroke();
        }
        ctx.fillStyle = '#000000';
        arrows.forEach(function(arrow) {
            drawArrow.apply(null, arrow);
        });
    }
    function displayGlyph(glyphIndex) {
        var canvas = document.getElementById('glyph'),
                ctx = canvas.getContext('2d'),
                width = canvas.width / 1,
                height = canvas.height / 1;
        ctx.clearRect(0, 0, width, height);
        if(glyphIndex < 0) return;
        var glyph = font.glyphs[glyphIndex],
                glyphWidth = glyph.advanceWidth * glyphScale,
                xmin = (width - glyphWidth)/2,
                xmax = (width + glyphWidth)/2,
                x0 = xmin,
                markSize = 10;
        ctx.fillStyle = '#606060';
        ctx.fillRect(xmin-markSize+1, glyphBaseline, markSize, 1);
        ctx.fillRect(xmin, glyphBaseline, 1, markSize);
        ctx.fillRect(xmax, glyphBaseline, markSize, 1);
        ctx.fillRect(xmax, glyphBaseline, 1, markSize);
        ctx.textAlign = 'center';
        ctx.fillText('0', xmin, glyphBaseline+markSize+10);
        ctx.fillText(glyph.advanceWidth, xmax, glyphBaseline+markSize+10);
        ctx.fillStyle = '#000000';
        var path = glyph.getPath(x0, glyphBaseline, glyphSize);
        path.fill = '#808080';
        path.stroke = '#000000';
        path.strokeWidth = 1.5;
        drawPathWithArrows(ctx, path);
        glyph.drawPoints(ctx, x0, glyphBaseline, glyphSize);
    }
    function initGlyphDisplay() {
        var glyphBgCanvas = document.getElementById('glyph-bg'),
                glyphW = glyphBgCanvas.width,
                glyphH = glyphBgCanvas.height,
                head = font.tables.head,
                maxHeight = head.yMax - head.yMin,
                maxWidth = head.xMax - head.xMin,
                ctx = glyphBgCanvas.getContext('2d');
        glyphScale = Math.min(glyphW/maxWidth, glyphH/maxHeight);
        glyphSize = glyphScale * font.unitsPerEm;
        glyphBaseline = glyphH * head.yMax / maxHeight;
        function hline(text, yunits) {
            ypx = glyphBaseline - yunits * glyphScale;
            ctx.fillText(text, 2, ypx+3);
            ctx.fillRect(80, ypx, glyphW, 1);
        }
        ctx.clearRect(0, 0, glyphW, glyphH);
        ctx.fillStyle = '#a0a0a0';
        hline('Baseline', 0);
        hline('yMax', font.tables.head.yMax);
        hline('yMin', font.tables.head.yMin);
        hline('Ascender', font.tables.hhea.ascender);
        hline('Descender', font.tables.hhea.descender);
    }
    function onFontLoaded(font) {
        window.font = font;
        initGlyphDisplay();
        displayGlyph(4);
        displayGlyphData(4);
    }
    opentype.load('latinmodern-math.otf', function (err, font) {
        onFontLoaded(font);
    });
</script>
</body>
</html>